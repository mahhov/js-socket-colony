<style>
    :root {
        --light-color: #f5f5f5;
        --dark-color: rgb(150, 180, 234);
        /*--dark-color: rgb(150, 150, 200);*/
        --almost-black: #00a;
    }

    body {
        font-family: monospace;
        font-size: 16px;
        color: var(--almost-black);
    }

    .container {
        display: flex;
        height: 100%;
        align-items: center;
        justify-content: center;
    }

    .lobby-container {
        width: 600px;
    }

    .title {
        font-size: 20px;
    }

    #game-list {
        height: 450px;
        border: 1px solid var(--almost-black);
        margin-top: 5px;
        padding: 15px 15px;
        overflow: auto;
    }

    .game-item {
        padding-top: 5px;
        padding-bottom: 5px;
    }

    .lobby-controls {
        margin-top: 10px;
    }

    .population-text {
        float: right;
    }

    button {
        border: 1px solid var(--almost-black);
        background: none;
        font: inherit;
        padding-left: 10px;
        padding-right: 10px;
    }

    .game-item:hover,
    button:hover {
        background: var(--light-color);
    }

    .game-item.selected,
    button:active {
        background: var(--dark-color);
        color: white;
    }
</style>

<div class="container">
    <div class="lobby-container">
        <div class="title">Lobby</div>
        <div id="game-list">
            <!--e.g. <div class="game-item selected" gameId="###'>game 1</div>-->
        </div>
        <div class="lobby-controls">
            <button id="create-game-button">create game</button>
            <button id="join-game-button">join game</button>
            <span class="population-text"><span
                    id="population-count-text"></span> clients in lobby</span>
        </div>
    </div>

    <div class="game-container">
        <canvas width=500 height=500></canvas>
    </div>
</div>

<script>
	const SEND_INPUTS_PERIOD_MS = 1000 / 20;
	const SERVER_URL = 'ws://localhost:3003';
	const DEBUG_GAME_VIEW = true;

	const GAME_STATE_ENUM = {
		WAITING_FOR_PLAYERS: 0,
		IN_PROGRESS: 1,
		ENDED: 2,
	};

	const INPUT_STATE_ENUM = {
		RELEASED: 1,
		PRESSED: 2,
		TAPPED: 3
	};

	const newPromise = () => {
		let resolve, reject;
		let promise = new Promise((res, rej) => {
			resolve = res;
			reject = rej;
		});
		promise.resolve = resolve;
		promise.reject = reject;
		return promise;
	};

	class View {
		constructor() {
			this.$ = query => document.querySelector(query);
			this.lobbyMode();
		}

		addCreateGameListener(listener) {
			this.$('#create-game-button').addEventListener('click', () => listener());
		}

		addJoinGameListener(listener) {
			this.$('#join-game-button').addEventListener('click', () => listener(this.selectedGameId));
		}

		lobbyMode() {
			this.$('.lobby-container').hidden = false;
			this.$('.game-container').hidden = true;
		}

		gameMode() {
			this.$('.lobby-container').hidden = true;
			this.$('.game-container').hidden = false;
		}

		updateLobby(population, games) {
			this.$('#population-count-text').textContent = population;

			let gameList = this.$('#game-list');
			for (let i = gameList.childElementCount; i < games.length; i++) {
				let gameItem = document.createElement('div');
				gameItem.classList.add('game-item');
				gameItem.addEventListener('click', () =>
					this.updateLobbySelected(gameItem));
				gameList.appendChild(gameItem)
			}
			while (gameList.childElementCount > games.length)
				gameList.lastChild.remove();

			games.forEach(({id, population, state}, i) => {
				let gameItem = gameList.children[i];
				gameItem.gameId = id;
				gameItem.textContent = `${id}: ${View.getGameStateText(state)} (${population} / ${2} players)`; // todo don't hardcode 2
			});
		};

		updateLobbySelected(selectedGameItem) {
			this.selectedGameId = selectedGameItem.gameId;
			[...this.$('#game-list').children].forEach(gameItem =>
				gameItem.classList.toggle('selected', gameItem === selectedGameItem));
		}

		static getGameStateText(state) {
			switch (state) {
				case GAME_STATE_ENUM.WAITING_FOR_PLAYERS:
					return 'waiting for players';
				case GAME_STATE_ENUM.IN_PROGRESS:
					return 'game in progress';
				case GAME_STATE_ENUM.ENDED:
					return 'game ended';
				default:
					console.warn('unrecognized game state:', state);
			}
		}
	}

	class Inputs {
		constructor() {
			this.resetAccumulatedInputs();
		}

		resetAccumulatedInputs() {
			this.accumulatedInputs = {
				keys: {},
				mouse: {},
			};
		}

		accumulateKeyInput(input) {
			Object.entries(input).forEach(([key, value]) => {
				if (value !== INPUT_STATE_ENUM.RELEASED)
					this.accumulatedInputs.keys[key] = value;

				// null -> release
				// release -> release
				// pressed -> tapped
				// tapped -> tapped
				else if (this.accumulatedInputs.keys[key] === INPUT_STATE_ENUM.PRESSED)
					this.accumulatedInputs.keys[key] = INPUT_STATE_ENUM.TAPPED;
				else if (!this.accumulatedInputs.keys[key])
					this.accumulatedInputs.keys[key] = INPUT_STATE_ENUM.RELEASED;
			});
		}

		accumulateMouseInput(x, y) {
			this.accumulatedInputs.mouse = {x, y};
		}

		getInputs() {
			let accumulatedInputs = this.accumulatedInputs;
			this.resetAccumulatedInputs();
			return accumulatedInputs;
		}
	}

	class GameState {
		constructor() {

		}

		setData(data) {
			this.data = data;
			this.draw();
		}

		draw() {
			// clear
			canvasCtx.fillStyle = 'rgb(0, 0, 0)';
			canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

			// geometry calc
			const FONT_SIZE = 24;
			let bottomPaneHeight = FONT_SIZE * 2 + 10;

			// board
			this.drawBoard(0, 10, canvas.width, canvas.height - bottomPaneHeight - 20);

			// prepare bottom panel
			canvasCtx.fillStyle = 'rgb(100, 100, 100)';
			canvasCtx.fillRect(0, canvas.height - bottomPaneHeight, canvas.width, bottomPaneHeight);
			canvasCtx.fillStyle = 'rgb(255, 255, 255)';
			canvasCtx.font = `${FONT_SIZE}px monospace`;

			// scores
			let scores = this.getScores();
			canvasCtx.fillText(`blue: ${scores[0]}`, 50, canvas.height - bottomPaneHeight + FONT_SIZE);
			canvasCtx.fillText(`green: ${scores[1]}`, 50, canvas.height - bottomPaneHeight + FONT_SIZE * 2);
		}

		getScores() {
			let flatBoard = this.data.board.flat();
			return [
				flatBoard.filter(a => a === 1).length,
				flatBoard.filter(a => a === 2).length];
		}

		drawBoard(left, top, width, height) {
			let tileSize = Math.min(width / this.data.width, height / this.data.height);
			left += (width - this.data.width * tileSize) / 2;
			top += (height - this.data.height * tileSize) / 2;

			for (let x = 0; x < this.data.width; x++)
				for (let y = 0; y < this.data.height; y++) {
					let tile = this.data.board[x][y];
					let selected = tile ?
						x === this.data.selected.x && y === this.data.selected.y :
						(x + y) % 2;
					let color = GameState.getColor(tile, selected);
					canvasCtx.fillStyle = `rgb(${color})`;
					canvasCtx.fillRect(x * tileSize + left, y * tileSize + top, tileSize, tileSize);
				}
		}

		static getColor(tile, selected) {
			const COLORS = [
				[[200, 200, 200], [230, 230, 230]], // background
				[[91, 69, 115], [152, 137, 167]], // player 1, normal & light
				[[170, 165, 96], [247, 244, 200]]]; // player 2, normal & light
			return COLORS[tile][selected + 0]; // +0 to convert bool to int
		}
	}

	class Controller {
		constructor(mouseTarget) {
			this.mouseTarget = mouseTarget;

			document.addEventListener('keydown', ({key, repeat}) =>
				!repeat && inputs.accumulateKeyInput({[key.toLowerCase()]: INPUT_STATE_ENUM.PRESSED}));

			document.addEventListener('keyup', ({key}) =>
				inputs.accumulateKeyInput({[key.toLowerCase()]: INPUT_STATE_ENUM.RELEASED}));

			document.addEventListener('mousemove', ({x, y}) =>
				this.mouseInput(x, y));

			document.addEventListener('mousedown', ({x, y}) => {
				this.mouseInput(x, y);
				inputs.accumulateKeyInput({mouse: INPUT_STATE_ENUM.PRESSED});
			});

			document.addEventListener('mouseup', ({x, y}) => {
				this.mouseInput(x, y);
				inputs.accumulateKeyInput({mouse: INPUT_STATE_ENUM.RELEASED});
			});
		}

		mouseInput(x, y) {
			inputs.accumulateMouseInput((x - this.mouseTarget.offsetLeft) / this.mouseTarget.width,
				(y - this.mouseTarget.offsetTop) / this.mouseTarget.height);
		}
	}

	class NetClient {
		constructor(serverUrl, messageHandler) {
			this.opened = newPromise();
			this.serverSocket = new WebSocket(serverUrl);
			this.serverSocket.addEventListener('open', () => this.opened.resolve());
			this.serverSocket.addEventListener('message', ({data}) => {
				try {
					messageHandler(JSON.parse(data));
				} catch (e) {
				}
			});
		}

		async send(data) {
			let stringData = JSON.stringify(data);
			await this.opened;
			this.serverSocket.send(stringData);
		}
	}

	let canvas = document.querySelector('canvas');
	let canvasCtx = canvas.getContext('2d');
	let gameState = new GameState();
	let inputs = new Inputs();
	let controller = new Controller(canvas);
	let view = new View();
	let client = {clientId: null, gameId: newPromise()};
	let netClient = new NetClient(SERVER_URL, message => {
		switch (message.type) {
			case 'created-client':
				client.clientId = message.clientId;
				netClient.send({
					type: 'join-lobby',
					clientId: client.clientId
				});
				break;
			case 'created-game':
				client.gameId.resolve(message.gameId);
				break;
			case 'lobby':
				view.updateLobby(message.population, message.games);
				break;
			case 'game':
				gameState.setData(message.data);
				break;
			default:
				console.warn('unrecognized message type:', message.type);
		}
	});
	view.addCreateGameListener(() => netClient.send({
		type: 'create-game',
		clientId: client.clientId
	}));
	view.addJoinGameListener(gameId => {
		netClient.send({
			type: 'join-game',
			clientId: client.clientId,
			gameId
		});
		client.gameId.resolve(gameId);
	});

	window.addEventListener('load', () =>
		netClient.send({type: 'create-client'}));

	client.gameId.then(gameId => {
		view.gameMode();
		setInterval(() =>
			netClient.send({
				type: 'input-game',
				repeat: true,
				clientId: client.clientId,
				gameId,
				input: inputs.getInputs(),
			}), SEND_INPUTS_PERIOD_MS)
	});

	if (DEBUG_GAME_VIEW) {
		view.gameMode();
		gameState.setData({
			'width': 10,
			'height': 10,
			'board': [[1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 0, 0, 0, 0], [0, 0, 2, 2, 2, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 2]],
			'turn': 0,
			'selected': {}
		});
	}

	// todo send input-game only if game started
	// todo send leave-game
	// todo indicate clientId and gameId (or names)
	// todo heartbeat for lobby count
	// todo hover tiile
	// todo print current turn
</script>
