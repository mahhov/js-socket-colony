<style>
    :root {
        --light-color: #f5f5f5;
        --dark-color: rgb(150, 180, 234);
        /*--dark-color: rgb(150, 150, 200);*/
        --almost-black: #00a;
    }

    body {
        font-family: monospace;
        font-size: 16px;
        color: var(--almost-black);
        user-select: none;
    }

    input,
    button {
        font: inherit;
    }

    .container {
        display: flex;
        height: 100%;
        align-items: center;
        justify-content: center;
    }

    .lobby-container {
        width: 800px;
    }

    .title {
        font-size: 20px;
    }

    .username {
        display: flex;
        align-items: center;
    }

    input {
        margin-left: 10px;
        flex-grow: 1;
    }

    .center {
        display: flex;
    }

    #game-list,
    #client-list {
        flex-basis: 0;
        height: 450px;
        border: 1px solid var(--almost-black);
        margin-top: 5px;
        padding: 15px 15px;
        overflow: auto;
    }

    #game-list {
        flex-grow: 3;
    }

    #client-list {
        flex-grow: 1;
        border-left: 0;
    }

    .game-item,
    .client-item {
        padding-top: 5px;
        padding-bottom: 5px;
    }

    .game-item {
        cursor: pointer;
    }

    .lobby-controls {
        margin-top: 10px;
    }

    .population-text {
        float: right;
    }

    button {
        border: 1px solid var(--almost-black);
        background: none;
        padding-left: 10px;
        padding-right: 10px;
        cursor: pointer;
    }

    .game-item:hover,
    button:hover {
        background: var(--light-color);
    }

    .game-item.selected,
    button:active {
        background: var(--dark-color);
        color: white;
    }
</style>

<div class="container">
    <div class="lobby-container">
        <div class="title">Lobby</div>
        <div class="username">
            username:<input id="username-input">
        </div>
        <div class="center">
            <div id="game-list">
                <!--e.g. <div class="game-item selected" gameId="###'>game 1</div>-->
            </div>
            <div id="client-list">
                <!--e.g. <div class="client-item">penguin</div>-->
            </div>
        </div>
        <div class="lobby-controls">
            <button id="create-game-button">create game</button>
            <button id="join-game-button">join game</button>
            <span class="population-text"><span id="population-count-text">0</span> clients in lobby</span>
        </div>
    </div>

    <div class="game-container">
        <div>
            <span></span>
            <span id="game-name"></span>
        </div>
        <canvas width=500 height=500></canvas>
    </div>
</div>

<script>
	const SEND_INPUTS_PERIOD_MS = 1000 / 20;
	const SERVER_URL = 'ws://localhost:3003';
	const DEBUG_GAME_VIEW = false;

	const GAME_STATE_ENUM = {
		WAITING_FOR_PLAYERS: 0,
		IN_PROGRESS: 1,
		ENDED: 2,
	};

	const INPUT_STATE_ENUM = {
		RELEASED: 1,
		PRESSED: 2,
		TAPPED: 3
	};

	const newPromise = () => {
		let resolve, reject;
		let promise = new Promise((res, rej) => {
			resolve = res;
			reject = rej;
		});
		promise.resolve = resolve;
		promise.reject = reject;
		return promise;
	};

	class View {
		constructor() {
			this.$ = query => document.querySelector(query);
			this.lobbyMode();
		}

		addUsernameChangeListener(listener) {
			this.$('#username-input').addEventListener('change', () =>
				listener(this.$('#username-input').value));
		}

		addCreateGameListener(listener) {
			this.$('#create-game-button').addEventListener('click', listener);
		}

		addJoinGameListener(listener) {
			this.$('#join-game-button').addEventListener('click', () => listener(this.selectedGameId));
		}

		lobbyMode() {
			this.$('.lobby-container').hidden = false;
			this.$('.game-container').hidden = true;
		}

		gameMode() {
			this.$('.lobby-container').hidden = true;
			this.$('.game-container').hidden = false;
		}

		setClientName(clientName) {
			this.$('#username-input').value = clientName;
		}

		updateLobby(population, clientNames, games) {
			this.$('#population-count-text').textContent = population;

			// todo extract client/game list logic to reusable helper
			let clientList = this.$('#client-list');
			for (let i = clientList.childElementCount; i < clientNames.length; i++) {
				let clientItem = document.createElement('div');
				clientItem.classList.add('client-item');
				clientItem.addEventListener('click', () =>
					this.updateLobbySelected(clientItem));
				clientList.appendChild(clientItem)
			}
			while (clientList.childElementCount > clientNames.length)
				clientList.lastChild.remove();

			clientNames.forEach((name, i) => {
				let clientItem = clientList.children[i];
				clientItem.textContent = name;
			});

			let gameList = this.$('#game-list');
			for (let i = gameList.childElementCount; i < games.length; i++) {
				let gameItem = document.createElement('div');
				gameItem.classList.add('game-item');
				gameItem.addEventListener('click', () =>
					this.updateLobbySelected(gameItem));
				gameList.appendChild(gameItem)
			}
			while (gameList.childElementCount > games.length)
				gameList.lastChild.remove();

			games.forEach(({id, name, state, population}, i) => {
				let gameItem = gameList.children[i];
				gameItem.gameId = id;
				gameItem.textContent = `${name}: ${View.getGameStateText(state)} (${population} / ${2} players)`; // todo don't hardcode 2
			});
		};

		updateLobbySelected(selectedGameItem) {
			this.selectedGameId = selectedGameItem.gameId;
			[...this.$('#game-list').children].forEach(gameItem =>
				gameItem.classList.toggle('selected', gameItem === selectedGameItem));
		}

		// updateGame(game)

		static getGameStateText(state) {
			switch (state) {
				case GAME_STATE_ENUM.WAITING_FOR_PLAYERS:
					return 'waiting for players';
				case GAME_STATE_ENUM.IN_PROGRESS:
					return 'game in progress';
				case GAME_STATE_ENUM.ENDED:
					return 'game ended';
				default:
					console.warn('unrecognized game state:', state);
			}
		}
	}

	class Inputs {
		constructor() {
			this.resetAccumulatedInputs();
		}

		resetAccumulatedInputs() {
			this.accumulatedInputs = {
				keys: {},
				mouse: {},
			};
		}

		accumulateKeyInput(input) {
			Object.entries(input).forEach(([key, value]) => {
				if (value !== INPUT_STATE_ENUM.RELEASED)
					this.accumulatedInputs.keys[key] = value;

				// null -> release
				// release -> release
				// pressed -> tapped
				// tapped -> tapped
				else if (this.accumulatedInputs.keys[key] === INPUT_STATE_ENUM.PRESSED)
					this.accumulatedInputs.keys[key] = INPUT_STATE_ENUM.TAPPED;
				else if (!this.accumulatedInputs.keys[key])
					this.accumulatedInputs.keys[key] = INPUT_STATE_ENUM.RELEASED;
			});
		}

		accumulateMouseInput(x, y) {
			this.accumulatedInputs.mouse = {x, y};
		}

		getInputs() {
			let accumulatedInputs = this.accumulatedInputs;
			this.resetAccumulatedInputs();
			return accumulatedInputs;
		}
	}

	class GameState {
		constructor() {

		}

		setData(data) {
			this.data = data;
			this.draw();
		}

		draw() {
			let geometry = this.getDrawGeometry();

			// clear
			canvasCtx.fillStyle = 'rgb(0, 0, 0)';
			canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

			// board
			this.drawBoard(geometry.boardLeft, geometry.boardTop, geometry.boardTileSize);

			// prepare bottom panel
			canvasCtx.fillStyle = 'rgb(100, 100, 100)';
			canvasCtx.fillRect(0, canvas.height - geometry.bottomPaneHeight, canvas.width, geometry.bottomPaneHeight);
			canvasCtx.fillStyle = 'rgb(255, 255, 255)';
			canvasCtx.font = `${geometry.fontSize}px monospace`;

			// scores
			let scores = this.getScores();
			canvasCtx.fillText(`blue: ${scores[0]}`, geometry.textMargin, canvas.height - geometry.bottomPaneHeight + geometry.fontSize);
			canvasCtx.fillText(`green: ${scores[1]}`, geometry.textMargin, canvas.height - geometry.bottomPaneHeight + geometry.fontSize * 2);

			// turn
			let turnText = this.getTurnText();
			let turnTextLeft = canvas.width - geometry.textMargin - canvasCtx.measureText(turnText).width;
			canvasCtx.fillText(turnText, turnTextLeft, canvas.height - geometry.bottomPaneHeight + geometry.fontSize);
		}

		getScores() {
			let flatBoard = this.data.board.flat();
			return [
				flatBoard.filter(a => a === 1).length,
				flatBoard.filter(a => a === 2).length];
		}

		getTurnText() {
			return ['blue', 'green'][this.data.turn] + "'s turn";
		}

		drawBoard(left, top, tileSize) {
			for (let x = 0; x < this.data.width; x++)
				for (let y = 0; y < this.data.height; y++) {
					let tile = this.data.board[x][y];
					let selected = tile ?
						x === this.data.selected.x && y === this.data.selected.y :
						(x + y) % 2;
					let color = GameState.getColor(tile, selected);
					canvasCtx.fillStyle = `rgb(${color})`;
					canvasCtx.fillRect(x * tileSize + left, y * tileSize + top, tileSize, tileSize);
				}
		}

		getDrawGeometry() {
			// todo cache once game width/height are set
			let fontSize = 24;
			let bottomPaneHeight = fontSize * 2 + 10;
			let textMargin = 50;

			let maxBoardLeft = 0;
			let maxBoardTop = 10;
			let maxBoardWidth = canvas.width;
			let maxBoardHeight = canvas.height - bottomPaneHeight - 20;

			let boardTileSize = Math.min(maxBoardWidth / this.data.width, maxBoardHeight / this.data.height);
			let boardLeft = maxBoardLeft + (maxBoardWidth - this.data.width * boardTileSize) / 2;
			let boardTop = maxBoardTop + (maxBoardHeight - this.data.height * boardTileSize) / 2;
			let boardWidth = this.data.width * boardTileSize;
			let boardHeight = this.data.height * boardTileSize;

			return {
				fontSize,
				bottomPaneHeight,
				textMargin,
				maxBoardLeft,
				maxBoardTop,
				maxBoardWidth,
				maxBoardHeight,
				boardTileSize,
				boardLeft,
				boardTop,
				boardWidth,
				boardHeight,
			};
		}

		static getColor(tile, selected) {
			const COLORS = [
				[[200, 200, 200], [230, 230, 230]], // background
				[[91, 69, 115], [152, 137, 167]], // player 1, normal & light
				[[170, 165, 96], [247, 244, 200]]]; // player 2, normal & light
			return COLORS[tile][selected + 0]; // +0 to convert bool to int
		}
	}

	class Controller {
		constructor(mouseTarget) {
			document.addEventListener('keydown', ({key, repeat}) =>
				!repeat && inputs.accumulateKeyInput({[key.toLowerCase()]: INPUT_STATE_ENUM.PRESSED}));

			document.addEventListener('keyup', ({key}) =>
				inputs.accumulateKeyInput({[key.toLowerCase()]: INPUT_STATE_ENUM.RELEASED}));

			mouseTarget.addEventListener('mousemove', ({offsetX, offsetY}) =>
				this.mouseInput(offsetX, offsetY));

			mouseTarget.addEventListener('mousedown', ({offsetX, offsetY}) => {
				this.mouseInput(offsetX, offsetY);
				inputs.accumulateKeyInput({mouse: INPUT_STATE_ENUM.PRESSED});
			});

			mouseTarget.addEventListener('mouseup', ({offsetX, offsetY}) => {
				this.mouseInput(offsetX, offsetY);
				inputs.accumulateKeyInput({mouse: INPUT_STATE_ENUM.RELEASED});
			});
		}

		mouseInput(x, y) {
			// todo should not be directly accessing gameState
			let {boardLeft, boardTop, boardTileSize, boardWidth, boardHeight} = gameState.getDrawGeometry();
			inputs.accumulateMouseInput((x - boardLeft) / boardWidth,
				(y - boardTop) / boardHeight);
		}
	}

	class NetClient {
		constructor(serverUrl, messageHandler) {
			this.opened = newPromise();
			this.serverSocket = new WebSocket(serverUrl);
			this.serverSocket.addEventListener('open', () => this.opened.resolve());
			this.serverSocket.addEventListener('message', ({data}) => {
				try {
					messageHandler(JSON.parse(data));
				} catch (e) {
				}
			});
		}

		async send(data) {
			let stringData = JSON.stringify(data);
			await this.opened;
			this.serverSocket.send(stringData);
		}
	}

	let canvas = document.querySelector('canvas');
	let canvasCtx = canvas.getContext('2d');
	let gameState = new GameState();
	let inputs = new Inputs();
	let controller = new Controller(canvas);
	let view = new View();
	let client = {clientId: null, gameId: newPromise()};
	let netClient = new NetClient(SERVER_URL, message => {
		switch (message.type) {
			case 'created-client':
				client.clientId = message.id;
				view.setClientName(message.name);
				break;
			case 'created-game':
				client.gameId.resolve(message.id);
				break;
			case 'lobby':
				view.updateLobby(message.population, message.clientNames, message.games);
				break;
			case 'game':
				gameState.setData(message.data);
				break;
			default:
				console.warn('unrecognized message type:', message.type);
		}
	});
	view.addUsernameChangeListener(name => netClient.send({
		type: 'change-client-name',
		clientId: client.clientId,
		name,
	}));
	view.addCreateGameListener(() => netClient.send({
		type: 'create-game',
		clientId: client.clientId
	}));
	view.addJoinGameListener(gameId => {
		netClient.send({
			type: 'join-game',
			clientId: client.clientId,
			gameId
		});
		client.gameId.resolve(gameId);
	});

	window.addEventListener('load', () =>
		netClient.send({type: 'create-client'}));

	client.gameId.then(gameId => {
		view.gameMode();
		setInterval(() =>
			netClient.send({
				type: 'input-game',
				clientId: client.clientId,
				gameId,
				input: inputs.getInputs(),
			}), SEND_INPUTS_PERIOD_MS)
	});

	if (DEBUG_GAME_VIEW) {
		view.gameMode();
		gameState.setData({
			'width': 10,
			'height': 10,
			'board': [[1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 0, 0, 0, 0], [0, 0, 2, 2, 2, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 2]],
			'turn': 0,
			'selected': {}
		});
	}

	// todo send input-game only if game started
	// todo send leave-game
	// todo indicate clientId and gameId (or names)
	// todo heartbeat for lobby count
	// todo hover tile
</script>
